import {describe, expect, it} from 'vitest'
import {parseRunTrace, replayRunTraces} from './runTraces'

function baseTrace() {
  const now = new Date().toISOString()
  return {
    id: crypto.randomUUID(),
    runId: 'run-1',
    tickId: 'tick-1',
    taskId: 'task-1',
    type: 'step' as const,
    stateId: 'done',
    fromStateId: 'work',
    toStateId: 'done',
    event: 'done',
    reason: 'action.done' as const,
    attempt: 1,
    loopIteration: 0,
    status: null,
    message: null,
    payloadJson: null,
    timestamp: now,
  }
}

describe('runTraces', () => {
  it('rejects step traces with missing transition fields', () => {
    const candidate = {
      ...baseTrace(),
      toStateId: null,
    }
    expect(() => parseRunTrace(candidate)).toThrow('step traces require toStateId')
  })

  it('rejects retry traces with invalid attempt counters', () => {
    const candidate = {
      ...baseTrace(),
      type: 'retry' as const,
      stateId: 'work',
      fromStateId: 'work',
      toStateId: 'work',
      event: 'failed',
      reason: 'action.attempt.failed' as const,
      attempt: 0,
    }
    expect(() => parseRunTrace(candidate)).toThrow('attempt >= 1')
  })

  it('replays lifecycle traces with feedback pause/resume continuity', () => {
    const now = new Date().toISOString()
    const replayed = replayRunTraces([
      {
        id: 'trace-1',
        runId: 'run-1',
        tickId: 'tick-1',
        taskId: 'task-1',
        type: 'started',
        stateId: 'work',
        fromStateId: null,
        toStateId: null,
        event: null,
        reason: null,
        attempt: 0,
        loopIteration: 0,
        status: 'running',
        message: 'Factory: demo',
        payloadJson: null,
        timestamp: now,
      },
      {
        id: 'trace-2',
        runId: 'run-1',
        tickId: 'tick-1',
        taskId: 'task-1',
        type: 'step',
        stateId: 'await_human',
        fromStateId: 'work',
        toStateId: 'await_human',
        event: 'feedback',
        reason: 'action.feedback',
        attempt: 1,
        loopIteration: 0,
        status: null,
        message: null,
        payloadJson: null,
        timestamp: now,
      },
      {
        id: 'trace-3',
        runId: 'run-1',
        tickId: 'tick-1',
        taskId: 'task-1',
        type: 'await_feedback',
        stateId: 'await_human',
        fromStateId: null,
        toStateId: null,
        event: null,
        reason: null,
        attempt: 0,
        loopIteration: 0,
        status: null,
        message: 'Please approve',
        payloadJson: null,
        timestamp: now,
      },
      {
        id: 'trace-4',
        runId: 'run-1',
        tickId: 'tick-2',
        taskId: 'task-1',
        type: 'resumed',
        stateId: 'work',
        fromStateId: null,
        toStateId: null,
        event: null,
        reason: null,
        attempt: 0,
        loopIteration: 0,
        status: null,
        message: 'Resumed with persisted state/context',
        payloadJson: null,
        timestamp: now,
      },
      {
        id: 'trace-5',
        runId: 'run-1',
        tickId: 'tick-2',
        taskId: 'task-1',
        type: 'step',
        stateId: 'done',
        fromStateId: 'work',
        toStateId: 'done',
        event: 'done',
        reason: 'action.done',
        attempt: 2,
        loopIteration: 0,
        status: null,
        message: null,
        payloadJson: null,
        timestamp: now,
      },
      {
        id: 'trace-6',
        runId: 'run-1',
        tickId: 'tick-2',
        taskId: 'task-1',
        type: 'completed',
        stateId: 'done',
        fromStateId: null,
        toStateId: null,
        event: null,
        reason: null,
        attempt: 0,
        loopIteration: 0,
        status: 'done',
        message: 'Factory reached terminal done state.',
        payloadJson: null,
        timestamp: now,
      },
    ])
    expect(replayed).toBe('done')
  })

  it('returns feedback when traces stop at await_feedback', () => {
    const now = new Date().toISOString()
    const replayed = replayRunTraces([
      {
        id: 'trace-1',
        runId: 'run-1',
        tickId: 'tick-1',
        taskId: 'task-1',
        type: 'started',
        stateId: 'work',
        fromStateId: null,
        toStateId: null,
        event: null,
        reason: null,
        attempt: 0,
        loopIteration: 0,
        status: 'running',
        message: null,
        payloadJson: null,
        timestamp: now,
      },
      {
        id: 'trace-2',
        runId: 'run-1',
        tickId: 'tick-1',
        taskId: 'task-1',
        type: 'step',
        stateId: 'await_human',
        fromStateId: 'work',
        toStateId: 'await_human',
        event: 'feedback',
        reason: 'action.feedback',
        attempt: 1,
        loopIteration: 0,
        status: null,
        message: null,
        payloadJson: null,
        timestamp: now,
      },
      {
        id: 'trace-3',
        runId: 'run-1',
        tickId: 'tick-1',
        taskId: 'task-1',
        type: 'await_feedback',
        stateId: 'await_human',
        fromStateId: null,
        toStateId: null,
        event: null,
        reason: null,
        attempt: 0,
        loopIteration: 0,
        status: null,
        message: 'Waiting',
        payloadJson: null,
        timestamp: now,
      },
    ])
    expect(replayed).toBe('feedback')
  })

  it('fails replay when state continuity breaks without feedback', () => {
    const now = new Date().toISOString()
    expect(() =>
      replayRunTraces([
        {
          id: 'trace-1',
          runId: 'run-1',
          tickId: 'tick-1',
          taskId: 'task-1',
          type: 'started',
          stateId: 'work',
          fromStateId: null,
          toStateId: null,
          event: null,
          reason: null,
          attempt: 0,
          loopIteration: 0,
          status: 'running',
          message: null,
          payloadJson: null,
          timestamp: now,
        },
        {
          id: 'trace-2',
          runId: 'run-1',
          tickId: 'tick-1',
          taskId: 'task-1',
          type: 'step',
          stateId: 'route',
          fromStateId: 'work',
          toStateId: 'route',
          event: 'done',
          reason: 'action.done',
          attempt: 1,
          loopIteration: 0,
          status: null,
          message: null,
          payloadJson: null,
          timestamp: now,
        },
        {
          id: 'trace-3',
          runId: 'run-1',
          tickId: 'tick-1',
          taskId: 'task-1',
          type: 'step',
          stateId: 'done',
          fromStateId: 'other',
          toStateId: 'done',
          event: 'matched',
          reason: 'orchestrate.select',
          attempt: 1,
          loopIteration: 0,
          status: null,
          message: null,
          payloadJson: null,
          timestamp: now,
        },
      ]),
    ).toThrow('Replay mismatch')
  })
})
